// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"
	"log"
	"net/url"

	"github.com/jhole89/orbital/ent/data"
	"github.com/jhole89/orbital/ent/metadata"
	"github.com/jhole89/orbital/ent/referencedata"

	"github.com/facebook/ent/dialect"
	"github.com/facebook/ent/dialect/gremlin"
	"github.com/facebook/ent/dialect/gremlin/graph/dsl"
	"github.com/facebook/ent/dialect/gremlin/graph/dsl/g"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Data is the client for interacting with the Data builders.
	Data *DataClient
	// MetaData is the client for interacting with the MetaData builders.
	MetaData *MetaDataClient
	// ReferenceData is the client for interacting with the ReferenceData builders.
	ReferenceData *ReferenceDataClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	cfg := config{log: log.Println, hooks: &hooks{}}
	cfg.options(opts...)
	client := &Client{config: cfg}
	client.init()
	return client
}

func (c *Client) init() {
	c.Data = NewDataClient(c.config)
	c.MetaData = NewMetaDataClient(c.config)
	c.ReferenceData = NewReferenceDataClient(c.config)
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.Gremlin:
		u, err := url.Parse(dataSourceName)
		if err != nil {
			return nil, err
		}
		c, err := gremlin.NewClient(gremlin.Config{
			Endpoint: gremlin.Endpoint{
				URL: u,
			},
		})
		if err != nil {
			return nil, err
		}
		drv := gremlin.NewDriver(c)
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, fmt.Errorf("ent: cannot start a transaction within a transaction")
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %v", err)
	}
	cfg := config{driver: tx, log: c.log, debug: c.debug, hooks: c.hooks}
	return &Tx{
		ctx:           ctx,
		config:        cfg,
		Data:          NewDataClient(cfg),
		MetaData:      NewMetaDataClient(cfg),
		ReferenceData: NewReferenceDataClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		Data.
//		Query().
//		Count(ctx)
//
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := config{driver: dialect.Debug(c.driver, c.log), log: c.log, debug: true, hooks: c.hooks}
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	c.Data.Use(hooks...)
	c.MetaData.Use(hooks...)
	c.ReferenceData.Use(hooks...)
}

// DataClient is a client for the Data schema.
type DataClient struct {
	config
}

// NewDataClient returns a client for the Data from the given config.
func NewDataClient(c config) *DataClient {
	return &DataClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `data.Hooks(f(g(h())))`.
func (c *DataClient) Use(hooks ...Hook) {
	c.hooks.Data = append(c.hooks.Data, hooks...)
}

// Create returns a create builder for Data.
func (c *DataClient) Create() *DataCreate {
	mutation := newDataMutation(c.config, OpCreate)
	return &DataCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// BulkCreate returns a builder for creating a bulk of Data entities.
func (c *DataClient) CreateBulk(builders ...*DataCreate) *DataCreateBulk {
	return &DataCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Data.
func (c *DataClient) Update() *DataUpdate {
	mutation := newDataMutation(c.config, OpUpdate)
	return &DataUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *DataClient) UpdateOne(d *Data) *DataUpdateOne {
	mutation := newDataMutation(c.config, OpUpdateOne, withData(d))
	return &DataUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *DataClient) UpdateOneID(id int) *DataUpdateOne {
	mutation := newDataMutation(c.config, OpUpdateOne, withDataID(id))
	return &DataUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Data.
func (c *DataClient) Delete() *DataDelete {
	mutation := newDataMutation(c.config, OpDelete)
	return &DataDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *DataClient) DeleteOne(d *Data) *DataDeleteOne {
	return c.DeleteOneID(d.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *DataClient) DeleteOneID(id int) *DataDeleteOne {
	builder := c.Delete().Where(data.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &DataDeleteOne{builder}
}

// Query returns a query builder for Data.
func (c *DataClient) Query() *DataQuery {
	return &DataQuery{config: c.config}
}

// Get returns a Data entity by its id.
func (c *DataClient) Get(ctx context.Context, id int) (*Data, error) {
	return c.Query().Where(data.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *DataClient) GetX(ctx context.Context, id int) *Data {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryHasTable queries the has_table edge of a Data.
func (c *DataClient) QueryHasTable(d *Data) *DataQuery {
	query := &DataQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *dsl.Traversal, _ error) {

		fromV = g.V(d.ID).Both(data.HasTableLabel)
		return fromV, nil
	}
	return query
}

// QueryHasField queries the has_field edge of a Data.
func (c *DataClient) QueryHasField(d *Data) *DataQuery {
	query := &DataQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *dsl.Traversal, _ error) {

		fromV = g.V(d.ID).Both(data.HasFieldLabel)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *DataClient) Hooks() []Hook {
	return c.hooks.Data
}

// MetaDataClient is a client for the MetaData schema.
type MetaDataClient struct {
	config
}

// NewMetaDataClient returns a client for the MetaData from the given config.
func NewMetaDataClient(c config) *MetaDataClient {
	return &MetaDataClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `metadata.Hooks(f(g(h())))`.
func (c *MetaDataClient) Use(hooks ...Hook) {
	c.hooks.MetaData = append(c.hooks.MetaData, hooks...)
}

// Create returns a create builder for MetaData.
func (c *MetaDataClient) Create() *MetaDataCreate {
	mutation := newMetaDataMutation(c.config, OpCreate)
	return &MetaDataCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// BulkCreate returns a builder for creating a bulk of MetaData entities.
func (c *MetaDataClient) CreateBulk(builders ...*MetaDataCreate) *MetaDataCreateBulk {
	return &MetaDataCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for MetaData.
func (c *MetaDataClient) Update() *MetaDataUpdate {
	mutation := newMetaDataMutation(c.config, OpUpdate)
	return &MetaDataUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *MetaDataClient) UpdateOne(md *MetaData) *MetaDataUpdateOne {
	mutation := newMetaDataMutation(c.config, OpUpdateOne, withMetaData(md))
	return &MetaDataUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *MetaDataClient) UpdateOneID(id int) *MetaDataUpdateOne {
	mutation := newMetaDataMutation(c.config, OpUpdateOne, withMetaDataID(id))
	return &MetaDataUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for MetaData.
func (c *MetaDataClient) Delete() *MetaDataDelete {
	mutation := newMetaDataMutation(c.config, OpDelete)
	return &MetaDataDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *MetaDataClient) DeleteOne(md *MetaData) *MetaDataDeleteOne {
	return c.DeleteOneID(md.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *MetaDataClient) DeleteOneID(id int) *MetaDataDeleteOne {
	builder := c.Delete().Where(metadata.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &MetaDataDeleteOne{builder}
}

// Query returns a query builder for MetaData.
func (c *MetaDataClient) Query() *MetaDataQuery {
	return &MetaDataQuery{config: c.config}
}

// Get returns a MetaData entity by its id.
func (c *MetaDataClient) Get(ctx context.Context, id int) (*MetaData, error) {
	return c.Query().Where(metadata.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *MetaDataClient) GetX(ctx context.Context, id int) *MetaData {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *MetaDataClient) Hooks() []Hook {
	return c.hooks.MetaData
}

// ReferenceDataClient is a client for the ReferenceData schema.
type ReferenceDataClient struct {
	config
}

// NewReferenceDataClient returns a client for the ReferenceData from the given config.
func NewReferenceDataClient(c config) *ReferenceDataClient {
	return &ReferenceDataClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `referencedata.Hooks(f(g(h())))`.
func (c *ReferenceDataClient) Use(hooks ...Hook) {
	c.hooks.ReferenceData = append(c.hooks.ReferenceData, hooks...)
}

// Create returns a create builder for ReferenceData.
func (c *ReferenceDataClient) Create() *ReferenceDataCreate {
	mutation := newReferenceDataMutation(c.config, OpCreate)
	return &ReferenceDataCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// BulkCreate returns a builder for creating a bulk of ReferenceData entities.
func (c *ReferenceDataClient) CreateBulk(builders ...*ReferenceDataCreate) *ReferenceDataCreateBulk {
	return &ReferenceDataCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ReferenceData.
func (c *ReferenceDataClient) Update() *ReferenceDataUpdate {
	mutation := newReferenceDataMutation(c.config, OpUpdate)
	return &ReferenceDataUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ReferenceDataClient) UpdateOne(rd *ReferenceData) *ReferenceDataUpdateOne {
	mutation := newReferenceDataMutation(c.config, OpUpdateOne, withReferenceData(rd))
	return &ReferenceDataUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ReferenceDataClient) UpdateOneID(id int) *ReferenceDataUpdateOne {
	mutation := newReferenceDataMutation(c.config, OpUpdateOne, withReferenceDataID(id))
	return &ReferenceDataUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ReferenceData.
func (c *ReferenceDataClient) Delete() *ReferenceDataDelete {
	mutation := newReferenceDataMutation(c.config, OpDelete)
	return &ReferenceDataDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *ReferenceDataClient) DeleteOne(rd *ReferenceData) *ReferenceDataDeleteOne {
	return c.DeleteOneID(rd.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *ReferenceDataClient) DeleteOneID(id int) *ReferenceDataDeleteOne {
	builder := c.Delete().Where(referencedata.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ReferenceDataDeleteOne{builder}
}

// Query returns a query builder for ReferenceData.
func (c *ReferenceDataClient) Query() *ReferenceDataQuery {
	return &ReferenceDataQuery{config: c.config}
}

// Get returns a ReferenceData entity by its id.
func (c *ReferenceDataClient) Get(ctx context.Context, id int) (*ReferenceData, error) {
	return c.Query().Where(referencedata.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ReferenceDataClient) GetX(ctx context.Context, id int) *ReferenceData {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *ReferenceDataClient) Hooks() []Hook {
	return c.hooks.ReferenceData
}
