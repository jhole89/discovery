// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"
	"sync"

	"github.com/jhole89/orbital/ent/data"

	"github.com/facebook/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeData          = "Data"
	TypeMetaData      = "MetaData"
	TypeReferenceData = "ReferenceData"
)

// DataMutation represents an operation that mutate the DataSlice
// nodes in the graph.
type DataMutation struct {
	config
	op               Op
	typ              string
	id               *int
	name             *string
	context          *string
	clearedFields    map[string]struct{}
	has_table        map[int]struct{}
	removedhas_table map[int]struct{}
	clearedhas_table bool
	has_field        map[int]struct{}
	removedhas_field map[int]struct{}
	clearedhas_field bool
	done             bool
	oldValue         func(context.Context) (*Data, error)
}

var _ ent.Mutation = (*DataMutation)(nil)

// dataOption allows to manage the mutation configuration using functional options.
type dataOption func(*DataMutation)

// newDataMutation creates new mutation for $n.Name.
func newDataMutation(c config, op Op, opts ...dataOption) *DataMutation {
	m := &DataMutation{
		config:        c,
		op:            op,
		typ:           TypeData,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDataID sets the id field of the mutation.
func withDataID(id int) dataOption {
	return func(m *DataMutation) {
		var (
			err   error
			once  sync.Once
			value *Data
		)
		m.oldValue = func(ctx context.Context) (*Data, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Data.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withData sets the old Data of the mutation.
func withData(node *Data) dataOption {
	return func(m *DataMutation) {
		m.oldValue = func(context.Context) (*Data, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DataMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DataMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *DataMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the name field.
func (m *DataMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *DataMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the Data.
// If the Data object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *DataMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *DataMutation) ResetName() {
	m.name = nil
}

// SetContext sets the context field.
func (m *DataMutation) SetContext(s string) {
	m.context = &s
}

// Context returns the context value in the mutation.
func (m *DataMutation) Context() (r string, exists bool) {
	v := m.context
	if v == nil {
		return
	}
	return *v, true
}

// OldContext returns the old context value of the Data.
// If the Data object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *DataMutation) OldContext(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldContext is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldContext requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContext: %w", err)
	}
	return oldValue.Context, nil
}

// ResetContext reset all changes of the "context" field.
func (m *DataMutation) ResetContext() {
	m.context = nil
}

// AddHasTableIDs adds the has_table edge to Data by ids.
func (m *DataMutation) AddHasTableIDs(ids ...int) {
	if m.has_table == nil {
		m.has_table = make(map[int]struct{})
	}
	for i := range ids {
		m.has_table[ids[i]] = struct{}{}
	}
}

// ClearHasTable clears the has_table edge to Data.
func (m *DataMutation) ClearHasTable() {
	m.clearedhas_table = true
}

// HasTableCleared returns if the edge has_table was cleared.
func (m *DataMutation) HasTableCleared() bool {
	return m.clearedhas_table
}

// RemoveHasTableIDs removes the has_table edge to Data by ids.
func (m *DataMutation) RemoveHasTableIDs(ids ...int) {
	if m.removedhas_table == nil {
		m.removedhas_table = make(map[int]struct{})
	}
	for i := range ids {
		m.removedhas_table[ids[i]] = struct{}{}
	}
}

// RemovedHasTable returns the removed ids of has_table.
func (m *DataMutation) RemovedHasTableIDs() (ids []int) {
	for id := range m.removedhas_table {
		ids = append(ids, id)
	}
	return
}

// HasTableIDs returns the has_table ids in the mutation.
func (m *DataMutation) HasTableIDs() (ids []int) {
	for id := range m.has_table {
		ids = append(ids, id)
	}
	return
}

// ResetHasTable reset all changes of the "has_table" edge.
func (m *DataMutation) ResetHasTable() {
	m.has_table = nil
	m.clearedhas_table = false
	m.removedhas_table = nil
}

// AddHasFieldIDs adds the has_field edge to Data by ids.
func (m *DataMutation) AddHasFieldIDs(ids ...int) {
	if m.has_field == nil {
		m.has_field = make(map[int]struct{})
	}
	for i := range ids {
		m.has_field[ids[i]] = struct{}{}
	}
}

// ClearHasField clears the has_field edge to Data.
func (m *DataMutation) ClearHasField() {
	m.clearedhas_field = true
}

// HasFieldCleared returns if the edge has_field was cleared.
func (m *DataMutation) HasFieldCleared() bool {
	return m.clearedhas_field
}

// RemoveHasFieldIDs removes the has_field edge to Data by ids.
func (m *DataMutation) RemoveHasFieldIDs(ids ...int) {
	if m.removedhas_field == nil {
		m.removedhas_field = make(map[int]struct{})
	}
	for i := range ids {
		m.removedhas_field[ids[i]] = struct{}{}
	}
}

// RemovedHasField returns the removed ids of has_field.
func (m *DataMutation) RemovedHasFieldIDs() (ids []int) {
	for id := range m.removedhas_field {
		ids = append(ids, id)
	}
	return
}

// HasFieldIDs returns the has_field ids in the mutation.
func (m *DataMutation) HasFieldIDs() (ids []int) {
	for id := range m.has_field {
		ids = append(ids, id)
	}
	return
}

// ResetHasField reset all changes of the "has_field" edge.
func (m *DataMutation) ResetHasField() {
	m.has_field = nil
	m.clearedhas_field = false
	m.removedhas_field = nil
}

// Op returns the operation name.
func (m *DataMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Data).
func (m *DataMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *DataMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.name != nil {
		fields = append(fields, data.FieldName)
	}
	if m.context != nil {
		fields = append(fields, data.FieldContext)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *DataMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case data.FieldName:
		return m.Name()
	case data.FieldContext:
		return m.Context()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *DataMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case data.FieldName:
		return m.OldName(ctx)
	case data.FieldContext:
		return m.OldContext(ctx)
	}
	return nil, fmt.Errorf("unknown Data field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *DataMutation) SetField(name string, value ent.Value) error {
	switch name {
	case data.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case data.FieldContext:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContext(v)
		return nil
	}
	return fmt.Errorf("unknown Data field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *DataMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *DataMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *DataMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Data numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *DataMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *DataMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *DataMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Data nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *DataMutation) ResetField(name string) error {
	switch name {
	case data.FieldName:
		m.ResetName()
		return nil
	case data.FieldContext:
		m.ResetContext()
		return nil
	}
	return fmt.Errorf("unknown Data field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *DataMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.has_table != nil {
		edges = append(edges, data.EdgeHasTable)
	}
	if m.has_field != nil {
		edges = append(edges, data.EdgeHasField)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *DataMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case data.EdgeHasTable:
		ids := make([]ent.Value, 0, len(m.has_table))
		for id := range m.has_table {
			ids = append(ids, id)
		}
		return ids
	case data.EdgeHasField:
		ids := make([]ent.Value, 0, len(m.has_field))
		for id := range m.has_field {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *DataMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedhas_table != nil {
		edges = append(edges, data.EdgeHasTable)
	}
	if m.removedhas_field != nil {
		edges = append(edges, data.EdgeHasField)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *DataMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case data.EdgeHasTable:
		ids := make([]ent.Value, 0, len(m.removedhas_table))
		for id := range m.removedhas_table {
			ids = append(ids, id)
		}
		return ids
	case data.EdgeHasField:
		ids := make([]ent.Value, 0, len(m.removedhas_field))
		for id := range m.removedhas_field {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *DataMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedhas_table {
		edges = append(edges, data.EdgeHasTable)
	}
	if m.clearedhas_field {
		edges = append(edges, data.EdgeHasField)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *DataMutation) EdgeCleared(name string) bool {
	switch name {
	case data.EdgeHasTable:
		return m.clearedhas_table
	case data.EdgeHasField:
		return m.clearedhas_field
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *DataMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Data unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *DataMutation) ResetEdge(name string) error {
	switch name {
	case data.EdgeHasTable:
		m.ResetHasTable()
		return nil
	case data.EdgeHasField:
		m.ResetHasField()
		return nil
	}
	return fmt.Errorf("unknown Data edge %s", name)
}

// MetaDataMutation represents an operation that mutate the MetaDataSlice
// nodes in the graph.
type MetaDataMutation struct {
	config
	op            Op
	typ           string
	id            *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*MetaData, error)
}

var _ ent.Mutation = (*MetaDataMutation)(nil)

// metadataOption allows to manage the mutation configuration using functional options.
type metadataOption func(*MetaDataMutation)

// newMetaDataMutation creates new mutation for $n.Name.
func newMetaDataMutation(c config, op Op, opts ...metadataOption) *MetaDataMutation {
	m := &MetaDataMutation{
		config:        c,
		op:            op,
		typ:           TypeMetaData,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMetaDataID sets the id field of the mutation.
func withMetaDataID(id int) metadataOption {
	return func(m *MetaDataMutation) {
		var (
			err   error
			once  sync.Once
			value *MetaData
		)
		m.oldValue = func(ctx context.Context) (*MetaData, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().MetaData.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMetaData sets the old MetaData of the mutation.
func withMetaData(node *MetaData) metadataOption {
	return func(m *MetaDataMutation) {
		m.oldValue = func(context.Context) (*MetaData, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MetaDataMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MetaDataMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *MetaDataMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// Op returns the operation name.
func (m *MetaDataMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (MetaData).
func (m *MetaDataMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *MetaDataMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *MetaDataMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *MetaDataMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown MetaData field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *MetaDataMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown MetaData field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *MetaDataMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *MetaDataMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *MetaDataMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown MetaData numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *MetaDataMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *MetaDataMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *MetaDataMutation) ClearField(name string) error {
	return fmt.Errorf("unknown MetaData nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *MetaDataMutation) ResetField(name string) error {
	return fmt.Errorf("unknown MetaData field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *MetaDataMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *MetaDataMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *MetaDataMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *MetaDataMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *MetaDataMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *MetaDataMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *MetaDataMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown MetaData unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *MetaDataMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown MetaData edge %s", name)
}

// ReferenceDataMutation represents an operation that mutate the ReferenceDataSlice
// nodes in the graph.
type ReferenceDataMutation struct {
	config
	op            Op
	typ           string
	id            *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*ReferenceData, error)
}

var _ ent.Mutation = (*ReferenceDataMutation)(nil)

// referencedataOption allows to manage the mutation configuration using functional options.
type referencedataOption func(*ReferenceDataMutation)

// newReferenceDataMutation creates new mutation for $n.Name.
func newReferenceDataMutation(c config, op Op, opts ...referencedataOption) *ReferenceDataMutation {
	m := &ReferenceDataMutation{
		config:        c,
		op:            op,
		typ:           TypeReferenceData,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withReferenceDataID sets the id field of the mutation.
func withReferenceDataID(id int) referencedataOption {
	return func(m *ReferenceDataMutation) {
		var (
			err   error
			once  sync.Once
			value *ReferenceData
		)
		m.oldValue = func(ctx context.Context) (*ReferenceData, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ReferenceData.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withReferenceData sets the old ReferenceData of the mutation.
func withReferenceData(node *ReferenceData) referencedataOption {
	return func(m *ReferenceDataMutation) {
		m.oldValue = func(context.Context) (*ReferenceData, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ReferenceDataMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ReferenceDataMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *ReferenceDataMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// Op returns the operation name.
func (m *ReferenceDataMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ReferenceData).
func (m *ReferenceDataMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *ReferenceDataMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *ReferenceDataMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *ReferenceDataMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown ReferenceData field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ReferenceDataMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ReferenceData field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *ReferenceDataMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *ReferenceDataMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ReferenceDataMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown ReferenceData numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *ReferenceDataMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *ReferenceDataMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *ReferenceDataMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ReferenceData nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *ReferenceDataMutation) ResetField(name string) error {
	return fmt.Errorf("unknown ReferenceData field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *ReferenceDataMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *ReferenceDataMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *ReferenceDataMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *ReferenceDataMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *ReferenceDataMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *ReferenceDataMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *ReferenceDataMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ReferenceData unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *ReferenceDataMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ReferenceData edge %s", name)
}
